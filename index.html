<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smart Globe AI</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: black;
    }

    /* ===== SHARED UI ===== */
    #matrix {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
      display: block;
      filter: blur(2px);
      opacity: 0.6;
    }

    #status {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      color: #00ff99;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.6);
      padding: 4px 10px;
      border-radius: 4px;
      z-index: 3;
    }

    #log {
      position: fixed;
      bottom: 110px;
      left: 12px;
      max-height: 30%;
      width: 320px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
      color: #00ff99;
      background: rgba(0,0,0,0.7);
      padding: 6px;
      border-radius: 4px;
      z-index: 3;
    }
    .msg-user { color: #9cf; }
    .msg-bot  { color: #0f0; }

    #chat {
      position: fixed;
      bottom: 12px;
      left: 12px;
      z-index: 3;
      display: flex;
      gap: 4px;
      align-items: center;
      font-family: monospace;
    }

    #chatInput {
      width: 260px;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #00ff99;
      background: rgba(0,0,0,0.7);
      color: #00ff99;
      outline: none;
    }

    #chatSend {
      padding: 4px 8px;
      border-radius: 4px;
      border: none;
      background: #00ff99;
      color: #000;
      cursor: pointer;
      font-size: 12px;
    }

    /* ===== CODER MODE UI ===== */
    #coderMicButton {
      position: fixed;
      bottom: 12px;
      right: 12px;
      z-index: 3;
      padding: 6px 10px;
      font-family: monospace;
      font-size: 13px;
      cursor: pointer;
      background: #00ff99;
      border: none;
      border-radius: 4px;
      display: none; /* hidden in hacker mode by default */
    }

    #coderPlayground {
      position: fixed;
      inset: 0;
      display: none;
      flex-direction: column;
      background: #0b141a;
      color: #e9edef;
      z-index: 50;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    /* ===== HACKER MODE UI ===== */
    #userCam {
      position: fixed;
      top: 12px;
      right: 12px;
      width: 160px;
      height: 120px;
      object-fit: cover;
      border-radius: 8px;
      border: 1px solid #00ff99;
      z-index: 3;
      background: #000;
      display: block;
    }

    #controlBar {
      position: fixed;
      bottom: 12px;
      right: 12px;
      z-index: 3;
      display: flex;
      gap: 8px;
      font-family: monospace;
    }

    #camToggleButton,
    #hackerMicButton {
      padding: 6px 10px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 4px;
      border: none;
    }

    #camToggleButton {
      background: #004433;
      color: #00ff99;
      border: 1px solid #00ff99;
    }

    #hackerMicButton {
      background: #00ff99;
      color: #000;
    }

    /* ===== MELT OVERLAY ===== */
    #meltOverlay {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 200;
      background: #000;
      color: #0ff;
      font-family: monospace;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    #blueMatrix {
      position: absolute;
      inset: 0;
    }
    #hahaha {
      position: relative;
      font-size: 24px;
      cursor: pointer;
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
    }

  </style>

  <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <!-- Shared background + UI -->
  <canvas id="matrix"></canvas>
  <div id="status">Status: idle (say "hey x" to wake, "matrix" to chill)</div>
  <div id="log"></div>

  <div id="chat">
    <input id="chatInput" type="text" placeholder="type here..." autocomplete="off" />
    <button id="chatSend">Send</button>
  </div>

  <!-- Coder voice button (shown in coder mode) -->
  <button id="coderMicButton">üéô Start Listening</button>

  <!-- Hacker-specific UI -->
  <video id="userCam" autoplay muted playsinline></video>
  <div id="controlBar">
    <button id="camToggleButton">üì∑ Sleep Camera</button>
    <button id="hackerMicButton">üéô Start Listening</button>
  </div>

  <!-- Melt overlay -->
  <div id="meltOverlay">
    <canvas id="blueMatrix"></canvas>
    <div id="hahaha">hahahaha</div>
  </div>

  <!-- CODER PLAYGROUND OVERLAY -->
  <div id="coderPlayground">
    <div style="
      display:flex;align-items:center;padding:8px 12px;
      border-bottom:1px solid #202c33;gap:8px;">
      <button id="coderBackBtn" style="
        padding:4px 8px;border-radius:4px;border:none;
        background:#202c33;color:#e9edef;font-size:12px;cursor:pointer;">
        ‚Üê Back
      </button>
      <div style="font-size:13px;opacity:0.8;">
        Hacker playground ‚Äì Smart Globe &amp; code pad
      </div>
    </div>

    <div style="flex:1;border-bottom:1px solid #202c33;background:#000;"></div>

    <div style="
      height:260px;display:flex;border-top:1px solid #202c33;background:#111b21;">
      <!-- Code input -->
      <div style="
        flex:1;display:flex;flex-direction:column;
        border-right:1px solid #202c33;padding:8px;gap:6px;">
        <div style="
          display:flex;justify-content:space-between;
          align-items:center;gap:8px;">
          <div style="font-size:12px;opacity:0.8;">
            Paste any code here. X can review/fix it. JavaScript can also run locally.
          </div>
          <select id="codeLang" style="
            background:#0b141a;color:#e9edef;border-radius:4px;
            border:1px solid #202c33;font-size:11px;padding:2px 6px;">
            <option value="auto">auto</option>
            <option value="javascript">javascript</option>
            <option value="typescript">typescript</option>
            <option value="python">python</option>
            <option value="java">java</option>
            <option value="csharp">c#</option>
            <option value="cpp">c++</option>
            <option value="go">go</option>
            <option value="rust">rust</option>
            <option value="sql">sql</option>
          </select>
        </div>

        <textarea id="codeInput" spellcheck="false" style="
          flex:1;background:#0b141a;color:#e9edef;border-radius:4px;
          border:1px solid #202c33;font-family:monospace;font-size:12px;
          padding:6px;resize:none;"
          placeholder="# any language works here
# X will infer or use the selector above
"></textarea>

        <div style="display:flex;gap:8px;">
          <button id="runLocalBtn" style="
            padding:4px 10px;border-radius:4px;border:none;
            background:#202c33;color:#e9edef;font-size:12px;cursor:pointer;">
            Run
          </button>
          <button id="reviewBtn" style="
            padding:4px 10px;border-radius:4px;border:none;
            background:#00a884;color:#fff;font-size:12px;cursor:pointer;">
            Ask X to review
          </button>
          <button id="saveBtn" style="
            padding:4px 10px;border-radius:4px;border:none;
            background:#202c33;color:#e9edef;font-size:12px;cursor:pointer;">
            Save
          </button>
          <button id="loadBtn" style="
            padding:4px 10px;border-radius:4px;border:none;
            background:#202c33;color:#e9edef;font-size:12px;cursor:pointer;">
            Load
          </button>
        </div>
      </div>

      <!-- X feedback + viz + cmd -->
      <div style="
        width:360px;display:flex;flex-direction:column;
        padding:8px;gap:6px;">
        <div style="font-size:12px;opacity:0.8;">X feedback / output</div>
        <textarea id="runOutput" readonly style="
          flex:1;background:#0b141a;color:#9ee;border-radius:4px;
          border:1px solid #202c33;font-family:monospace;
          font-size:12px;padding:6px;resize:none;"
          placeholder="Run results or X feedback will appear here."></textarea>

        <div style="font-size:12px;opacity:0.8;">visual</div>
        <canvas id="viz" width="320" height="100"
          style="background:#000;border-radius:4px;border:1px solid #202c33;"></canvas>

        <div style="font-size:12px;opacity:0.8;">cmd</div>
        <div id="cmdLog" style="
          height:80px;background:#0b141a;border-radius:4px;border:1px solid #202c33;
          font-family:monospace;font-size:11px;color:#9ee;padding:4px;overflow-y:auto;"></div>
      </div>
    </div>
  </div>

  <script>
    // ===== DOM & STATE =====
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');

    const coderMicButton = document.getElementById('coderMicButton');
    const hackerMicButton = document.getElementById('hackerMicButton');
    const userCam = document.getElementById('userCam');
    const controlBar = document.getElementById('controlBar');
    const coderPanel = document.getElementById('coderPlayground');
    const coderBackBtn = document.getElementById('coderBackBtn');

    const langSelect   = document.getElementById('codeLang');
    const codeInput    = document.getElementById('codeInput');
    const runOutputEl  = document.getElementById('runOutput');
    const runLocalBtn  = document.getElementById('runLocalBtn');
    const reviewBtn    = document.getElementById('reviewBtn');
    const saveBtn      = document.getElementById('saveBtn');
    const loadBtn      = document.getElementById('loadBtn');
    const vizCanvas    = document.getElementById('viz');
    const vizCtx       = vizCanvas.getContext('2d');
    const cmdLog       = document.getElementById('cmdLog');

    const meltOverlay  = document.getElementById('meltOverlay');
    const blueMatrix   = document.getElementById('blueMatrix');
    const hahaha       = document.getElementById('hahaha');

    let uiMode = 'hacker'; // hacker / coder
    let mode = 'idle';     // alive / idle
    let recognition;
    let listening = false;
    let reviewing = false;

    // colors for matrix background
    let matrixColor = '#0F0';
    const allowedColors = {
      red:   '#ff0000',
      blue:  '#00ccff',
      white: '#ffffff',
      green: '#00ff00'
    };

    // ===== MODE HANDLING =====
    function setMode(newMode) {
      uiMode = newMode;

      if (uiMode === 'coder') {
        coderPanel.style.display = 'flex';
        coderMicButton.style.display = 'block';
        userCam.style.display = 'none';
        controlBar.style.display = 'none';
        statusEl.textContent = 'Status: coder mode';
      } else {
        coderPanel.style.display = 'none';
        coderMicButton.style.display = 'none';
        userCam.style.display = 'block';
        controlBar.style.display = 'flex';
        statusEl.textContent = 'Status: hacker mode';
        initUserCamera();
        loadFaceModels();
      }
    }

    coderBackBtn.addEventListener('click', () => {
      setMode('hacker');
    });

    // ===== AUDIO + CHAT HELPERS =====
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const synth = window.speechSynthesis;

    function matrixBeep(freq = 900, duration = 0.12) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.value = freq;
      gain.gain.value = 0.08;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.0, now);
      gain.gain.linearRampToValueAtTime(0.08, now + 0.01);
      gain.gain.linearRampToValueAtTime(0.0, now + duration);
      osc.start(now);
      osc.stop(now + duration);
    }

    function speak(text) {
      if (!synth) return;
      const utter = new SpeechSynthesisUtterance(text);
      utter.rate = 1.0;
      utter.pitch = 1.1;
      utter.lang = 'en-US';
      synth.cancel();
      synth.speak(utter);
    }

    function addMsg(from, text) {
      const div = document.createElement('div');
      div.className = from === 'you' ? 'msg-user' : 'msg-bot';
      div.textContent = (from === 'you'
        ? 'you: '
        : (uiMode === 'hacker' ? 'hacker x: ' : 'xenos: ')) + text;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function coderHello() {
      const reply = 'coder pad open. paste code or ask me to fix it.';
      addMsg('xenos', reply);
      speak(reply);
    }

    function hackerHello() {
      const reply =
        "yo. i'm Hacker X. this globe is my lab. ask what i can do or say 'coding' to open the pad.";
      addMsg('xenos', reply);
      speak(reply);
    }

    // ===== VOICE / SPEECH RECOGNITION =====
    function updateStatus(message) {
      statusEl.textContent = 'Status: ' + message;
    }

    function handleWake() {
      mode = 'alive';
      updateStatus('alive (you woke the globe)');
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      matrixBeep(950, 0.12);
      setTimeout(() => matrixBeep(1250, 0.10), 120);
      if (uiMode === 'hacker') {
        hackerHello();
      } else {
        coderHello();
      }
    }

    function handleMatrix() {
      mode = 'idle';
      updateStatus('idle (matrix mode, just rotating)');
      matrixBeep(500, 0.1);
    }

    function initSpeech() {
      const SpeechRecognition =
        window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        updateStatus('Speech not supported in this browser (use Chrome/Edge)');
        coderMicButton.disabled = true;
        hackerMicButton.disabled = true;
        return;
      }

      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onstart = () => {
        listening = true;
        if (uiMode === 'hacker') {
          hackerMicButton.textContent = 'üõë Stop Listening';
        } else {
          coderMicButton.textContent = 'üõë Stop Listening';
        }
        updateStatus(
          mode === 'alive'
            ? 'alive (listening...)'
            : 'idle (listening, say "hey x")'
        );
      };

      recognition.onend = () => {
        listening = false;
        coderMicButton.textContent = 'üéô Start Listening';
        hackerMicButton.textContent = 'üéô Start Listening';
        updateStatus(
          mode === 'alive'
            ? 'alive (not listening)'
            : 'idle (not listening)'
        );
      };

      recognition.onerror = (event) => {
        console.error('Speech error', event);
        updateStatus('error with mic / speech');
      };

      recognition.onresult = async (event) => {
        const last = event.results[event.results.length - 1];
        if (!last.isFinal) return;
        const transcript = last[0].transcript.toLowerCase().trim();
        addMsg('you', transcript);
        await handleUserIntent(transcript);
      };
    }

    function toggleMic() {
      if (!recognition) {
        initSpeech();
      }
      if (!recognition) return;
      if (!listening) {
        recognition.start();
      } else {
        recognition.stop();
      }
    }

    coderMicButton.addEventListener('click', toggleMic);
    hackerMicButton.addEventListener('click', toggleMic);

    // ===== TEXT + INTENT HANDLING =====
    async function handleUserIntent(text) {
      const lower = text.toLowerCase();

      if (lower.includes('coding')) {
        const msg = "opening coder pad. paste code or ask me to fix it.";
        setMode('coder');
        addMsg('xenos', msg);
        speak(msg);
        return;
      }

      if (lower.includes('what can you do') || lower.includes('what can u do')) {
        const msg = "i can chat, help you code, run small experiments, and react to colors. try saying 'coding' or 'blue matrix'.";
        addMsg('xenos', msg);
        speak(msg);
        return;
      }

      // color control
      const colorWords = ['red','blue','white','green'];
      const foundColor = colorWords.find(c => lower.includes(c));
      if (foundColor) {
        matrixColor = allowedColors[foundColor];
        const msg = `matrix color set to ${foundColor}.`;
        addMsg('xenos', msg);
        speak(msg);
        return;
      } else if (lower.includes('color')) {
        const msg = "that color doesn't exist yet. colors available are red, blue, white, and green.";
        addMsg('xenos', msg);
        speak(msg);
        return;
      }

      if (lower.includes('hey x')) {
        handleWake();
        return;
      }
      if (lower.includes('matrix')) {
        handleMatrix();
        return;
      }

      if (mode === 'alive') {
        await handleAiReply(text);
      } else {
        const reply = "i'm idle. say 'hey x' to wake me.";
        addMsg('xenos', reply);
        speak(reply);
      }
    }

    function handleUserText(text) {
      const cleaned = text.trim();
      if (!cleaned) return;
      addMsg('you', cleaned);
      handleUserIntent(cleaned);
    }

    chatSend.addEventListener('click', () => {
      handleUserText(chatInput.value);
      chatInput.value = '';
    });
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        handleUserText(chatInput.value);
        chatInput.value = '';
      }
    });

    // ===== AI HANDLER (stub ‚Äì plug your API) =====
    async function handleAiReply(text) {
      // Replace this stub with your real API call if you want
      const reply = uiMode === 'hacker'
        ? "Hacker X stub reply to: " + text
        : "Xenos stub reply to: " + text;
      addMsg('xenos', reply);
      speak(reply);
    }

    // ===== CODER PLAYGROUND =====
    function setRunOutput(text) {
      runOutputEl.value = text;
    }

    function cmd(line) {
      const div = document.createElement('div');
      div.textContent = '> ' + line;
      cmdLog.appendChild(div);
      cmdLog.scrollTop = cmdLog.scrollHeight;
    }

    saveBtn.addEventListener('click', () => {
      localStorage.setItem('xenos-code', codeInput.value);
      cmd('saved code to browser storage.');
    });

    loadBtn.addEventListener('click', () => {
      const saved = localStorage.getItem('xenos-code');
      if (saved != null) {
        codeInput.value = saved;
        cmd('loaded saved code.');
      } else {
        cmd('no saved code found.');
      }
    });

    runLocalBtn.addEventListener('click', () => {
      const code = codeInput.value.trim();
      const lang = langSelect.value;
      if (!code) return;

      if (lang !== 'javascript' && lang !== 'auto') {
        setRunOutput(
          "Local run is only supported for JavaScript in the browser.\n" +
          "Switch language to 'javascript' or use Ask X to review for other languages."
        );
        return;
      }

      try {
        // expose vizCtx and cmd to code
        const f = new Function('vizCtx', 'cmd', code);
        const result = f(vizCtx, cmd);
        setRunOutput("Local run result:\n" + String(result));
      } catch (err) {
        setRunOutput("Local run error:\n" + err.message);
      }
    });

    reviewBtn.addEventListener('click', async () => {
      const code = codeInput.value.trim();
      const lang = langSelect.value;
      if (!code || reviewing) return;

      reviewing = true;
      reviewBtn.textContent = "X is thinking...";
      reviewBtn.style.background = "#444";
      reviewBtn.style.cursor = "default";
      setRunOutput("X is reading your code...");

      try {
        const res = await fetch("http://localhost:5000/api/xenos-hacker/fix", { // adjust URL
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            code,
            error: null,
            language: lang === "auto" ? null : lang,
          }),
        });

        const data = await res.json();
        if (data.error) {
          setRunOutput("Error from hacker brain: " + data.error);
          return;
        }

        const fixed = data.fixedCode || code;
        const explanation = data.explanation || "X adjusted your code for potential issues.";
        setRunOutput(
          `X suggestion${lang !== "auto" ? " (" + lang + ")" : ""}:\n\n` +
          fixed + "\n\n---\n" +
          explanation + "\n\nEdit anything you want and run/review again."
        );
      } catch (err) {
        setRunOutput("Could not reach X hacker API: " + err.message);
      } finally {
        reviewing = false;
        reviewBtn.textContent = "Ask X to review";
        reviewBtn.style.background = "#00a884";
        reviewBtn.style.cursor = "pointer";
      }
    });

    // ===== MATRIX BACKGROUND =====
    const canvas = document.getElementById('matrix');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const letters =
      '„Ç¢„Ç°„Ç´„Çµ„Çø„Éä„Éè„Éû„É§„É£„É©„ÉØ„Ç¨„Ç∂„ÉÄ„Éê„Éë„Ç§„Ç£„Ç≠„Ç∑„ÉÅ„Éã„Éí„Éü„É™„É∞„ÇÆ„Ç∏„ÉÇ„Éì„Éî„Ç¶„Ç•„ÇØ„Çπ„ÉÑ„Éå„Éï„É†„É¶„É•„É´„Ç∞„Ç∫„Éñ„ÉÖ„Éó„Ç®„Çß„Ç±„Çª„ÉÜ„Éç„Éò„É°„É¨„É±„Ç≤„Çº„Éá„Éô„Éö„Ç™„Ç©„Ç≥„ÇΩ„Éà„Éé„Éõ„É¢„É®„Éß„É≠„É≤„Ç¥„Çæ„Éâ„Éú„Éù„É¥„ÉÉ„É≥0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const fontSize = 16;
    let columns = Math.floor(canvas.width / fontSize);
    const drops = [];
    for (let i = 0; i < columns; i++) drops[i] = 1;

    function drawMatrix() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = matrixColor;
      ctx.font = fontSize + 'px monospace';
      for (let i = 0; i < drops.length; i++) {
        const text = letters.charAt(Math.floor(Math.random() * letters.length));
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);
        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
        drops[i]++;
      }
    }
    setInterval(drawMatrix, 33);
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      columns = Math.floor(canvas.width / fontSize);
      blueMatrix.width = window.innerWidth;
      blueMatrix.height = window.innerHeight;
    });

    // ===== THREE.JS GLOBE & ANIMATION =====
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.position = 'fixed';
    renderer.domElement.style.top = '50%';
    renderer.domElement.style.left = '50%';
    renderer.domElement.style.transform = 'translate(-50%, -50%)';
    renderer.domElement.style.zIndex = 1;
    document.body.appendChild(renderer.domElement);

    const pointCount = 800;
    const radius = 1.8;

    const positions = new Float32Array(pointCount * 3);
    const originalPositions = new Float32Array(pointCount * 3);
    for (let i = 0; i < pointCount; i++) {
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
      originalPositions[i * 3] = x;
      originalPositions[i * 3 + 1] = y;
      originalPositions[i * 3 + 2] = z;
    }

    const pointGeometry = new THREE.BufferGeometry();
    pointGeometry.setAttribute(
      'position',
      new THREE.BufferAttribute(positions, 3)
    );

    const pointMaterial = new THREE.PointsMaterial({
      color: 0x00ffff,
      size: 0.04,
      transparent: true,
      opacity: 0.9
    });

    const pointCloud = new THREE.Points(pointGeometry, pointMaterial);
    const maxConnectionsDistance = 0.7;
    const linePositions = new Float32Array(pointCount * pointCount * 3 * 2 * 0.02);
    const lineGeometry = new THREE.BufferGeometry();
    lineGeometry.setAttribute(
      'position',
      new THREE.BufferAttribute(linePositions, 3).setUsage(THREE.DynamicDrawUsage)
    );
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.35
    });
    const lineSegments = new THREE.LineSegments(lineGeometry, lineMaterial);

    const group = new THREE.Group();
    group.add(pointCloud);
    group.add(lineSegments);
    scene.add(group);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0x00ffcc, 0.6);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    const globeColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffffff];
    let colorIndex = 0;
    setInterval(() => {
      colorIndex = (colorIndex + 1) % globeColors.length;
      const hex = globeColors[colorIndex];
      pointMaterial.color.setHex(hex);
      lineMaterial.color.setHex(hex);
    }, 900);

    let userStream = null;
    let cameraAwake = false;
    let faceModelsLoaded = false;
    let lastFaceSeen = false;
    let exploding = false;
    let exploded = false;
    let explosionProgress = 0;
    let explosionDir = new Float32Array(pointCount * 3);
    let explosionTimer = 0;
    let isDragging = false;
    let draggingForMove = false;
    let lastX = 0;
    let lastY = 0;
    let dragRotX = 0;
    let dragRotY = 0;
    let scaleTarget = 1;
    let currentScale = 1;
    let bouncePhase = 0;
    let time = 0;

    async function initUserCamera() {
      if (userStream || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 320, height: 240, facingMode: "user" },
          audio: false,
        });
        userStream = stream;
        userCam.srcObject = stream;
        cameraAwake = true;
      } catch (err) {
        console.error("Error accessing camera:", err);
        const msg = "camera blocked or unavailable. enable camera for Hacker X to see you.";
        addMsg("xenos", msg);
        speak(msg);
      }
    }

    function stopUserCamera() {
      if (userStream) {
        userStream.getTracks().forEach(t => t.stop());
        userStream = null;
      }
      userCam.srcObject = null;
      cameraAwake = false;
    }

    const camToggleButton = document.getElementById('camToggleButton');
    camToggleButton.addEventListener('click', async () => {
      if (cameraAwake) {
        stopUserCamera();
        camToggleButton.textContent = 'üì∑ Wake Camera';
        addMsg('xenos', 'camera is sleeping. i cannot see you now.');
        speak('Camera is sleeping. I cannot see you now.');
      } else {
        await initUserCamera();
        if (cameraAwake) {
          camToggleButton.textContent = 'üì∑ Sleep Camera';
          addMsg('xenos', 'camera awake. i can see you again.');
          speak('Camera awake. I can see you again.');
        }
      }
    });

    async function loadFaceModels() {
      if (faceModelsLoaded || !window.faceapi) return;
      const MODEL_URL = "https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights";
      await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
      faceModelsLoaded = true;
      addMsg("xenos", "vision core loaded. if i see your face, i wake up.");
    }

    async function checkFaceLoop() {
      if (uiMode !== 'hacker' || !faceModelsLoaded || !cameraAwake || !userStream) {
        lastFaceSeen = false;
        return;
      }
      if (userCam.readyState >= 2) {
        const detections = await faceapi.detectAllFaces(
          userCam,
          new faceapi.TinyFaceDetectorOptions({ scoreThreshold: 0.5 })
        );
        const seen = detections.length > 0;
        if (seen && !lastFaceSeen) {
          if (mode !== 'alive') {
            handleWake();
          } else {
            const line = "i see you leaning into the matrix. stay there.";
            addMsg("xenos", line);
            speak(line);
          }
        }
        lastFaceSeen = seen;
      }
    }
    setInterval(checkFaceLoop, 500);

    for (let i = 0; i < pointCount; i++) {
      let rx = (Math.random() - 0.5);
      let ry = (Math.random() - 0.5);
      let rz = (Math.random() - 0.5);
      const len = Math.hypot(rx, ry, rz) || 1;
      rx /= len; ry /= len; rz /= len;
      explosionDir[i * 3]     = rx;
      explosionDir[i * 3 + 1] = ry;
      explosionDir[i * 3 + 2] = rz;
    }

    function triggerExplosion() {
      if (uiMode !== 'hacker') return;
      if (exploding) return;
      exploding = true;
      exploded = false;
      explosionProgress = 0;
      explosionTimer = 0;
      addMsg("xenos", "globe integrity compromised. disassembling network.");
      speak("Globe integrity compromised. Disassembling network.");
    }

    // ===== CROSS-TAB MELT (BroadcastChannel) =====
    const channel = new BroadcastChannel('xenos-globe');
    let melting = false;
    let blueCtx;
    let blueDrops;
    let blueCols;
    let blueMatrixLoopStarted = false;

    channel.onmessage = (event) => {
      if (!event.data) return;
      if (event.data.type === 'melt') startMelt();
      if (event.data.type === 'unmelt') {
        if (melting) endMelt(false);
      }
    };

    function startMelt() {
      if (melting) return;
      melting = true;
      meltOverlay.style.display = 'flex';
      initBlueMatrix();
      addMsg('xenos', 'realities colliding. melting interface.');
      speak('Realities colliding. Melting interface.');
    }

    function endMelt(broadcast = true) {
      melting = false;
      meltOverlay.style.display = 'none';
      addMsg('xenos', 'ok, enough. back to normal.');
      speak('ok, enough. back to normal.');
      if (broadcast) channel.postMessage({ type: 'unmelt' });
    }

    hahaha.addEventListener('click', () => {
      endMelt(true);
    });

    function initBlueMatrix() {
      blueMatrix.width = window.innerWidth;
      blueMatrix.height = window.innerHeight;
      blueCtx = blueMatrix.getContext('2d');
      const size = 18;
      blueCols = Math.floor(blueMatrix.width / size);
      blueDrops = Array(blueCols).fill(1);

      if (!blueMatrixLoopStarted) {
        blueMatrixLoopStarted = true;
        setInterval(drawBlueMatrix, 33);
      }
    }

    function drawBlueMatrix() {
      if (!melting || !blueCtx) return;
      blueCtx.fillStyle = 'rgba(0,0,30,0.2)';
      blueCtx.fillRect(0, 0, blueMatrix.width, blueMatrix.height);
      blueCtx.fillStyle = '#00ccff';
      blueCtx.font = '18px monospace';
      for (let i = 0; i < blueDrops.length; i++) {
        const text = letters.charAt(Math.floor(Math.random() * letters.length));
        blueCtx.fillText(text, i * 18, blueDrops[i] * 18);
        if (blueDrops[i] * 18 > blueMatrix.height && Math.random() > 0.975) blueDrops[i] = 0;
        blueDrops[i]++;
      }
    }

    // click globe triggers explosion + melt in all tabs
    renderer.domElement.addEventListener('click', () => {
      triggerExplosion();
      channel.postMessage({ type: 'melt' });
      startMelt();
    });

    // ===== DRAG / ROTATE / MOVE GLOBE =====
    renderer.domElement.addEventListener('mousedown', (e) => {
      if (uiMode !== 'hacker') return;
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      scaleTarget = 1.3;
      draggingForMove = e.shiftKey;
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
      scaleTarget = 1.0;
    });

    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;
      const rotSpeed = 0.005;
      const moveSpeed = 0.01;

      if (draggingForMove) {
        group.position.x += dx * moveSpeed;
        group.position.y -= dy * moveSpeed;
      } else {
        dragRotY += dx * rotSpeed;
        dragRotX += dy * rotSpeed;
      }
    });

    renderer.domElement.addEventListener('touchstart', (e) => {
      if (uiMode !== 'hacker' || e.touches.length !== 1) return;
      isDragging = true;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
      scaleTarget = 1.3;
      draggingForMove = false; // could use two fingers for move if you want
    });

    window.addEventListener('touchend', () => {
      isDragging = false;
      scaleTarget = 1.0;
    });

    window.addEventListener('touchmove', (e) => {
      if (!isDragging || e.touches.length !== 1) return;
      const t = e.touches[0];
      const dx = t.clientX - lastX;
      const dy = t.clientY - lastY;
      lastX = t.clientX;
      lastY = t.clientY;
      const rotSpeed = 0.005;
      dragRotY += dx * rotSpeed;
      dragRotX += dy * rotSpeed;
    });

    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;
      const positionsAttr = pointGeometry.getAttribute('position');

      const baseScale = 1;
      const extra = mode === 'alive' ? 0.35 * Math.sin(time * 1.3) : 0;
      const breathingScale = baseScale + extra;

      if (exploding) {
        if (!exploded) {
          explosionProgress += 0.02;
          if (explosionProgress >= 1) {
            explosionProgress = 1;
            exploded = true;
            explosionTimer = 0;
          }
        } else {
          explosionTimer += 1 / 60;
          if (explosionTimer > 5) {
            explosionProgress -= 0.02;
            if (explosionProgress <= 0) {
              explosionProgress = 0;
              exploding = false;
              exploded = false;
              addMsg("xenos", "network reassembled. globe back online.");
              speak("Network reassembled. Globe back online.");
            }
          }
        }
      }

      for (let i = 0; i < pointCount; i++) {
        const ox = originalPositions[i * 3];
        const oy = originalPositions[i * 3 + 1];
        const oz = originalPositions[i * 3 + 2];

        let x = ox * breathingScale;
        let y = oy * breathingScale;
        let z = oz * breathingScale;

        const jitterStrength = mode === 'alive' ? 0.03 : 0.01;
        x += Math.sin(time * 2 + i) * jitterStrength;
        y += Math.cos(time * 1.7 + i * 0.5) * jitterStrength;
        z += Math.sin(time * 1.3 + i * 0.3) * jitterStrength;

        if (explosionProgress > 0) {
          const dirX = explosionDir[i * 3];
          const dirY = explosionDir[i * 3 + 1];
          const dirZ = explosionDir[i * 3 + 2];
          const maxDist = 2.5;
          const t = explosionProgress;
          const ease = t * t * (3 - 2 * t);
          x += dirX * maxDist * ease;
          y += dirY * maxDist * ease;
          z += dirZ * maxDist * ease;
        }

        positionsAttr.array[i * 3]     = x;
        positionsAttr.array[i * 3 + 1] = y;
        positionsAttr.array[i * 3 + 2] = z;
      }
      positionsAttr.needsUpdate = true;

      let lineIndex = 0;
      const maxDistSq = maxConnectionsDistance * maxConnectionsDistance;
      for (let i = 0; i < pointCount; i++) {
        const ix = positionsAttr.array[i * 3];
        const iy = positionsAttr.array[i * 3 + 1];
        const iz = positionsAttr.array[i * 3 + 2];
        for (let j = i + 1; j < pointCount; j++) {
          const jx = positionsAttr.array[j * 3];
          const jy = positionsAttr.array[j * 3 + 1];
          const jz = positionsAttr.array[j * 3 + 2];
          const dx = ix - jx;
          const dy = iy - jy;
          const dz = iz - jz;
          const distSq = dx * dx + dy * dy + dz * dz;
          if (distSq < maxDistSq) {
            linePositions[lineIndex++] = ix;
            linePositions[lineIndex++] = iy;
            linePositions[lineIndex++] = iz;
            linePositions[lineIndex++] = jx;
            linePositions[lineIndex++] = jy;
            linePositions[lineIndex++] = jz;
            if (lineIndex / 6 > pointCount * 3) break;
          }
        }
      }
      lineGeometry.setDrawRange(0, lineIndex / 3);
      lineGeometry.attributes.position.needsUpdate = true;

      const scaleLerp = 0.15;
      currentScale += (scaleTarget - currentScale) * scaleLerp;

      bouncePhase += 0.12;
      const bounceHeight = mode === 'alive' ? 0.25 : 0.12;
      const bounceOffset = Math.abs(Math.sin(bouncePhase)) * bounceHeight;

      group.scale.set(currentScale, currentScale, currentScale);
      group.position.y = bounceOffset;

      const targetX = dragRotX * 0.8;
      const targetY = dragRotY * 0.8;
      const follow = mode === 'alive' ? 0.18 : 0.08;
      group.rotation.y += (targetY - group.rotation.y) * follow;
      group.rotation.x += (targetX - group.rotation.x) * follow;

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // start in hacker mode
    setMode('hacker');
  </script>
</body>
</html>
