<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smart Globe AI</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: black;
    }

    #matrix {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
      display: block;
      filter: blur(2px);
      opacity: 0.6;
    }

    #status {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      color: #00ff99;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.6);
      padding: 4px 10px;
      border-radius: 4px;
      z-index: 3;
    }

    #log {
      position: fixed;
      bottom: 110px;
      left: 12px;
      max-height: 30%;
      width: 320px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
      color: #00ff99;
      background: rgba(0,0,0,0.7);
      padding: 6px;
      border-radius: 4px;
      z-index: 3;
    }
    .msg-user { color: #9cf; }
    .msg-bot  { color: #0f0; }

    #chat {
      position: fixed;
      bottom: 12px;
      left: 12px;
      z-index: 3;
      display: flex;
      gap: 4px;
      align-items: center;
      font-family: monospace;
    }

    #chatInput {
      width: 260px;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #00ff99;
      background: rgba(0,0,0,0.7);
      color: #00ff99;
      outline: none;
    }

    #chatSend {
      padding: 4px 8px;
      border-radius: 4px;
      border: none;
      background: #00ff99;
      color: #000;
      cursor: pointer;
      font-size: 12px;
    }

    #coderMicButton {
      position: fixed;
      bottom: 12px;
      right: 12px;
      z-index: 3;
      padding: 6px 10px;
      font-family: monospace;
      font-size: 13px;
      cursor: pointer;
      background: #00ff99;
      border: none;
      border-radius: 4px;
      display: none;
    }

    #coderPlayground {
      position: fixed;
      inset: 0;
      display: none;
      flex-direction: column;
      background: #000;
      color: #e9edef;
      z-index: 50;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    #userCam {
      position: fixed;
      top: 12px;
      right: 12px;
      width: 160px;
      height: 120px;
      object-fit: cover;
      border-radius: 8px;
      border: 1px solid #00ff99;
      z-index: 3;
      background: #000;
      display: block;
    }

    #controlBar {
      position: fixed;
      bottom: 12px;
      right: 12px;
      z-index: 3;
      display: flex;
      gap: 8px;
      font-family: monospace;
    }

    #camToggleButton,
    #hackerMicButton {
      padding: 6px 10px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 4px;
      border: none;
    }

    #camToggleButton {
      background: #004433;
      color: #00ff99;
      border: 1px solid #00ff99;
    }

    #hackerMicButton {
      background: #00ff99;
      color: #000;
    }

    #meltOverlay {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 200;
      background: #000;
      color: #0ff;
      font-family: monospace;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    #blueMatrix {
      position: absolute;
      inset: 0;
    }
    #xenosText {
      position: relative;
      font-size: 24px;
      cursor: pointer;
      color: #0ff;
      text-shadow: 0 0 10px #0ff;
    }

    /* coder layout similar to your screenshot */
    #coderTopBar {
      height: 32px;
      display: flex;
      align-items: center;
      padding: 4px 8px;
      border-bottom: 1px solid #202c33;
      font-size: 12px;
    }
    #coderMain {
      flex: 1;
      display: grid;
      grid-template-columns: 260px 1fr 320px;
      grid-template-rows: 1fr;
      background: #000;
    }
    #coderFiles {
      border-right: 1px solid #202c33;
      background: #010b10;
      display: flex;
      flex-direction: column;
    }
    #coderEditor {
      border-right: 1px solid #202c33;
      background: #000;
      display: flex;
      flex-direction: column;
    }
    #coderRight {
      background: #010b10;
      display: flex;
      flex-direction: column;
    }

    #fileList {
      flex: 1;
      padding: 6px;
      font-family: monospace;
      font-size: 12px;
      color: #e9edef;
    }
    #debugButtons {
      padding: 6px;
      border-top: 1px solid #202c33;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    .debugBtn {
      padding: 4px 8px;
      border-radius: 16px;
      border: 1px solid #00ff99;
      background: #001b13;
      color: #00ff99;
      font-size: 11px;
      cursor: pointer;
    }
    #codeInput {
      flex: 1;
      background: #000;
      color: #e9edef;
      border: none;
      outline: none;
      font-family: monospace;
      font-size: 12px;
      padding: 6px;
      resize: none;
    }
    #editorBottomBar {
      padding: 4px 6px;
      border-top: 1px solid #202c33;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #viz {
      width: 100%;
      height: 140px;
      background: #000;
      border-bottom: 1px solid #202c33;
    }
    #cmdLog {
      flex: 1;
      background: #000;
      color: #9ee;
      font-family: monospace;
      font-size: 11px;
      padding: 4px;
      overflow-y: auto;
    }
    #runOutput {
      height: 120px;
      background: #050b0f;
      color: #9ee;
      border-top: 1px solid #202c33;
      border-left: none;
      border-right: none;
      border-bottom: none;
      font-family: monospace;
      font-size: 12px;
      padding: 4px;
      resize: none;
    }
  </style>

  <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <canvas id="matrix"></canvas>
  <div id="status">Status: idle (say "hey x" to wake, "matrix" to chill)</div>
  <div id="log"></div>

  <div id="chat">
    <input id="chatInput" type="text" placeholder="type here..." autocomplete="off" />
    <button id="chatSend">Send</button>
  </div>

  <button id="coderMicButton">üéô Start Listening</button>

  <video id="userCam" autoplay muted playsinline></video>
  <div id="controlBar">
    <button id="camToggleButton">üì∑ Sleep Camera</button>
    <button id="hackerMicButton">üéô Start Listening</button>
  </div>

  <div id="meltOverlay">
    <canvas id="blueMatrix"></canvas>
    <div id="xenosText">I AM XENOS ‚Äì THE CREATOR</div>
  </div>

  <!-- CODER PLAYGROUND -->
  <div id="coderPlayground">
    <div id="coderTopBar">
      <button id="coderBackBtn" style="margin-right:8px;padding:2px 8px;border-radius:4px;border:none;background:#202c33;color:#e9edef;cursor:pointer;">‚Üê Back</button>
      <span>Left: files + debug. Middle: code + visual. Right: cmd + X output.</span>
    </div>
    <div id="coderMain">
      <div id="coderFiles">
        <div id="fileList">
          <div>files</div>
          <div style="margin-top:4px;">welcome.js</div>
        </div>
        <div id="debugButtons">
          <button class="debugBtn">Find bugs</button>
          <button class="debugBtn">Explain</button>
          <button class="debugBtn">Refactor</button>
          <button class="debugBtn">Restructure</button>
        </div>
      </div>
      <div id="coderEditor">
        <canvas id="viz"></canvas>
        <textarea id="codeInput" spellcheck="false"
          placeholder="// write or paste code here. xenos can run JS and review any language."></textarea>
        <div id="editorBottomBar">
          <select id="codeLang" style="background:#000;color:#e9edef;border-radius:4px;border:1px solid #202c33;font-size:11px;padding:2px 6px;">
            <option value="auto">auto</option>
            <option value="javascript">javascript</option>
            <option value="typescript">typescript</option>
            <option value="python">python</option>
            <option value="java">java</option>
            <option value="csharp">c#</option>
            <option value="cpp">c++</option>
            <option value="go">go</option>
            <option value="rust">rust</option>
            <option value="sql">sql</option>
          </select>
          <button id="runLocalBtn" style="padding:3px 8px;border-radius:4px;border:none;background:#202c33;color:#e9edef;font-size:11px;cursor:pointer;">Run (JS)</button>
          <button id="reviewBtn" style="padding:3px 8px;border-radius:4px;border:none;background:#00a884;color:#fff;font-size:11px;cursor:pointer;">Ask X to review</button>
          <button id="saveBtn" style="padding:3px 8px;border-radius:4px;border:none;background:#202c33;color:#e9edef;font-size:11px;cursor:pointer;">Save</button>
          <button id="loadBtn" style="padding:3px 8px;border-radius:4px;border:none;background:#202c33;color:#e9edef;font-size:11px;cursor:pointer;">Load</button>
        </div>
      </div>
      <div id="coderRight">
        <div id="cmdLog"></div>
        <textarea id="runOutput" readonly placeholder="Xenos output / explanations appear here."></textarea>
      </div>
    </div>
  </div>

  <script>
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');

    const coderMicButton = document.getElementById('coderMicButton');
    const hackerMicButton = document.getElementById('hackerMicButton');
    const userCam = document.getElementById('userCam');
    const controlBar = document.getElementById('controlBar');
    const coderPanel = document.getElementById('coderPlayground');
    const coderBackBtn = document.getElementById('coderBackBtn');

    const langSelect   = document.getElementById('codeLang');
    const codeInput    = document.getElementById('codeInput');
    const runOutputEl  = document.getElementById('runOutput');
    const runLocalBtn  = document.getElementById('runLocalBtn');
    const reviewBtn    = document.getElementById('reviewBtn');
    const saveBtn      = document.getElementById('saveBtn');
    const loadBtn      = document.getElementById('loadBtn');
    const vizCanvas    = document.getElementById('viz');
    const vizCtx       = vizCanvas.getContext('2d');
    const cmdLog       = document.getElementById('cmdLog');

    const meltOverlay  = document.getElementById('meltOverlay');
    const blueMatrix   = document.getElementById('blueMatrix');
    const xenosText    = document.getElementById('xenosText');

    let uiMode = 'hacker';
    let mode = 'idle';
    let recognition;
    let listening = false;
    let reviewing = false;

    let matrixColor = '#0F0';
    const allowedColors = {
      red:   '#ff0000',
      blue:  '#00ccff',
      white: '#ffffff',
      green: '#00ff00'
    };

    function setMode(newMode) {
      uiMode = newMode;
      if (uiMode === 'coder') {
        coderPanel.style.display = 'flex';
        coderMicButton.style.display = 'block';
        userCam.style.display = 'none';
        controlBar.style.display = 'none';
        statusEl.textContent = 'Status: coder mode';
      } else {
        coderPanel.style.display = 'none';
        coderMicButton.style.display = 'none';
        userCam.style.display = 'block';
        controlBar.style.display = 'flex';
        statusEl.textContent = 'Status: hacker mode';
        initUserCamera();
        loadFaceModels();
      }
    }
    coderBackBtn.addEventListener('click', () => setMode('hacker'));

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const synth = window.speechSynthesis;

    function matrixBeep(freq = 900, duration = 0.12) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.value = freq;
      gain.gain.value = 0.08;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.0, now);
      gain.gain.linearRampToValueAtTime(0.08, now + 0.01);
      gain.gain.linearRampToValueAtTime(0.0, now + duration);
      osc.start(now);
      osc.stop(now + duration);
    }

    function speak(text) {
      if (!synth) return;
      const utter = new SpeechSynthesisUtterance(text);
      utter.rate = 1.0;
      utter.pitch = 1.1;
      utter.lang = 'en-US';
      synth.cancel();
      synth.speak(utter);
    }

    function addMsg(from, text) {
      const div = document.createElement('div');
      div.className = from === 'you' ? 'msg-user' : 'msg-bot';
      div.textContent = (from === 'you'
        ? 'you: '
        : (uiMode === 'hacker' ? 'hacker x: ' : 'xenos: ')) + text;
      logEl.appendChild(div);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function coderHello() {
      const reply = 'coder pad open. paste code or ask me to fix it.';
      addMsg('xenos', reply);
      speak(reply);
    }
    function hackerHello() {
      const reply = "yo. i\'m Hacker X. this globe is my lab. ask what i can do or say 'coding' to open the pad.";
      addMsg('xenos', reply);
      speak(reply);
    }

    function updateStatus(message) {
      statusEl.textContent = 'Status: ' + message;
    }
    function handleWake() {
      mode = 'alive';
      updateStatus('alive (you woke the globe)');
      if (audioCtx.state === 'suspended') audioCtx.resume();
      matrixBeep(950, 0.12);
      setTimeout(() => matrixBeep(1250, 0.10), 120);
      if (uiMode === 'hacker') hackerHello(); else coderHello();
    }
    function handleMatrix() {
      mode = 'idle';
      updateStatus('idle (matrix mode, just rotating)');
      matrixBeep(500, 0.1);
    }

    function initSpeech() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        updateStatus('Speech not supported in this browser');
        coderMicButton.disabled = true;
        hackerMicButton.disabled = true;
        return;
      }
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onstart = () => {
        listening = true;
        if (uiMode === 'hacker') hackerMicButton.textContent = 'üõë Stop Listening';
        else coderMicButton.textContent = 'üõë Stop Listening';
        updateStatus(mode === 'alive' ? 'alive (listening...)' : 'idle (listening, say "hey x")');
      };
      recognition.onend = () => {
        listening = false;
        coderMicButton.textContent = 'üéô Start Listening';
        hackerMicButton.textContent = 'üéô Start Listening';
        updateStatus(mode === 'alive' ? 'alive (not listening)' : 'idle (not listening)');
      };
      recognition.onerror = () => updateStatus('error with mic / speech');
      recognition.onresult = async (event) => {
        const last = event.results[event.results.length - 1];
        if (!last.isFinal) return;
        const transcript = last[0].transcript.toLowerCase().trim();
        addMsg('you', transcript);
        await handleUserIntent(transcript);
      };
    }
    function toggleMic() {
      if (!recognition) initSpeech();
      if (!recognition) return;
      if (!listening) recognition.start(); else recognition.stop();
    }
    coderMicButton.addEventListener('click', toggleMic);
    hackerMicButton.addEventListener('click', toggleMic);

    async function handleUserIntent(text) {
      const lower = text.toLowerCase();

      if (lower.includes('mix')) {
        channel.postMessage({ type: 'mix' });
        startMix();
        return;
      }

      if (lower.includes('coding')) {
        const msg = "opening coder pad. paste code or ask me to fix it.";
        setMode('coder');
        addMsg('xenos', msg);
        speak(msg);
        return;
      }

      if (lower.includes('what can you do') || lower.includes('what can u do')) {
        const msg = "i can chat, help you code, run small experiments, mix globes, and react to colors. try saying 'coding' or 'blue matrix'.";
        addMsg('xenos', msg);
        speak(msg);
        return;
      }

      const colorWords = ['red','blue','white','green'];
      const foundColor = colorWords.find(c => lower.includes(c));
      if (foundColor) {
        matrixColor = allowedColors[foundColor];
        const msg = `matrix color set to ${foundColor}.`;
        addMsg('xenos', msg);
        speak(msg);
        return;
      } else if (lower.includes('color')) {
        const msg = "that color doesn't exist yet. colors available are red, blue, white, and green.";
        addMsg('xenos', msg);
        speak(msg);
        return;
      }

      if (lower.includes('hey x')) { handleWake(); return; }
      if (lower.includes('matrix')) { handleMatrix(); return; }

      if (mode === 'alive') {
        await handleAiReply(text);
      } else {
        const reply = "i'm idle. say 'hey x' to wake me.";
        addMsg('xenos', reply);
        speak(reply);
      }
    }

    function handleUserText(text) {
      const cleaned = text.trim();
      if (!cleaned) return;
      addMsg('you', cleaned);
      handleUserIntent(cleaned);
    }
    chatSend.addEventListener('click', () => { handleUserText(chatInput.value); chatInput.value=''; });
    chatInput.addEventListener('keydown', e => { if (e.key==='Enter'){handleUserText(chatInput.value);chatInput.value='';}});

    // ==== TALK TO YOUR AI BACKEND ====
    async function handleAiReply(text) {
      try {
        const res = await fetch("http://localhost:5000/api/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            message: text,
            mode: uiMode
          }),
        });
        const data = await res.json();
        const reply = data.reply || "xenos api did not send a reply.";
        addMsg('xenos', reply);
        speak(reply);
      } catch (err) {
        const msg = "could not reach xenos api: " + err.message;
        addMsg('xenos', msg);
        speak(msg);
      }
    }

    // coder cmd util
    function setRunOutput(text) { runOutputEl.value = text; }
    function cmd(line) {
      const div = document.createElement('div');
      div.textContent = '> ' + line;
      cmdLog.appendChild(div);
      cmdLog.scrollTop = cmdLog.scrollHeight;
    }

    saveBtn.addEventListener('click', () => {
      localStorage.setItem('xenos-code', codeInput.value);
      cmd('saved code to browser storage.');
    });
    loadBtn.addEventListener('click', () => {
      const saved = localStorage.getItem('xenos-code');
      if (saved != null) { codeInput.value = saved; cmd('loaded saved code.'); }
      else cmd('no saved code found.');
    });

    runLocalBtn.addEventListener('click', () => {
      const code = codeInput.value.trim();
      const lang = langSelect.value;
      if (!code) return;
      if (lang !== 'javascript' && lang !== 'auto') {
        setRunOutput("Local run only supports JavaScript.\nUse Ask X to review for other languages.");
        return;
      }
      try {
        const f = new Function('vizCtx', 'cmd', code);
        const result = f(vizCtx, cmd);
        setRunOutput("Local run result:\n" + String(result));
      } catch (err) {
        setRunOutput("Local run error:\n" + err.message);
      }
    });

    reviewBtn.addEventListener('click', async () => {
      const code = codeInput.value.trim();
      const lang = langSelect.value;
      if (!code || reviewing) return;
      reviewing = true;
      reviewBtn.textContent = "X is thinking...";
      reviewBtn.style.background = "#444";
      reviewBtn.style.cursor = "default";
      setRunOutput("X is reading your code...");
      try {
        const res = await fetch("http://localhost:5000/api/fix", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            code,
            error: null,
            language: lang === "auto" ? null : lang,
          }),
        });
        const data = await res.json();
        const fixed = data.fixedCode || code;
        const explanation = data.explanation || "X adjusted your code for potential issues.";
        setRunOutput("fixed code:\n\n" + fixed + "\n\n---\n" + explanation);
      } catch (err) {
        setRunOutput("Could not reach Xenos fix API: " + err.message);
      } finally {
        reviewing = false;
        reviewBtn.textContent = "Ask X to review";
        reviewBtn.style.background = "#00a884";
        reviewBtn.style.cursor = "pointer";
      }
    });

    // ===== MATRIX BACKGROUND =====
    const canvas = document.getElementById('matrix');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const letters =
      '„Ç¢„Ç°„Ç´„Çµ„Çø„Éä„Éè„Éû„É§„É£„É©„ÉØ„Ç¨„Ç∂„ÉÄ„Éê„Éë„Ç§„Ç£„Ç≠„Ç∑„ÉÅ„Éã„Éí„Éü„É™„É∞„ÇÆ„Ç∏„ÉÇ„Éì„Éî„Ç¶„Ç•„ÇØ„Çπ„ÉÑ„Éå„Éï„É†„É¶„É•„É´„Ç∞„Ç∫„Éñ„ÉÖ„Éó„Ç®„Çß„Ç±„Çª„ÉÜ„Éç„Éò„É°„É¨„É±„Ç≤„Çº„Éá„Éô„Éö„Ç™„Ç©„Ç≥„ÇΩ„Éà„Éé„Éõ„É¢„É®„Éß„É≠„É≤„Ç¥„Çæ„Éâ„Éú„Éù„É¥„ÉÉ„É≥0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const fontSize = 16;
    let columns = Math.floor(canvas.width / fontSize);
    const drops = [];
    for (let i = 0; i < columns; i++) drops[i] = 1;
    function drawMatrix() {
      ctx.fillStyle = 'rgba(0,0,0,0.05)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = matrixColor;
      ctx.font = fontSize + 'px monospace';
      for (let i=0;i<drops.length;i++){
        const text = letters.charAt(Math.floor(Math.random()*letters.length));
        ctx.fillText(text,i*fontSize,drops[i]*fontSize);
        if (drops[i]*fontSize>canvas.height && Math.random()>0.975) drops[i]=0;
        drops[i]++;
      }
    }
    setInterval(drawMatrix,33);
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      columns = Math.floor(canvas.width / fontSize);
      blueMatrix.width = window.innerWidth;
      blueMatrix.height = window.innerHeight;
    });

    // ===== THREE GLOBE =====
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight,0.1,1000);
    camera.position.z = 5;
    const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.domElement.style.position='fixed';
    renderer.domElement.style.top='50%';
    renderer.domElement.style.left='50%';
    renderer.domElement.style.transform='translate(-50%,-50%)';
    renderer.domElement.style.zIndex=1;
    document.body.appendChild(renderer.domElement);

    const pointCount=800,radius=1.8;
    const positionsArr=new Float32Array(pointCount*3);
    const originalPositions=new Float32Array(pointCount*3);
    for(let i=0;i<pointCount;i++){
      const u=Math.random();const v=Math.random();
      const theta=2*Math.PI*u;const phi=Math.acos(2*v-1);
      const x=radius*Math.sin(phi)*Math.cos(theta);
      const y=radius*Math.sin(phi)*Math.sin(theta);
      const z=radius*Math.cos(phi);
      positionsArr[i*3]=x;positionsArr[i*3+1]=y;positionsArr[i*3+2]=z;
      originalPositions[i*3]=x;originalPositions[i*3+1]=y;originalPositions[i*3+2]=z;
    }
    const pointGeometry=new THREE.BufferGeometry();
    pointGeometry.setAttribute('position',new THREE.BufferAttribute(positionsArr,3));
    const pointMaterial=new THREE.PointsMaterial({color:0x00ffff,size:0.04,transparent:true,opacity:0.9});
    const pointCloud=new THREE.Points(pointGeometry,pointMaterial);
    const maxConnectionsDistance=0.7;
    const linePositions=new Float32Array(pointCount*pointCount*3*2*0.02);
    const lineGeometry=new THREE.BufferGeometry();
    lineGeometry.setAttribute('position',new THREE.BufferAttribute(linePositions,3).setUsage(THREE.DynamicDrawUsage));
    const lineMaterial=new THREE.LineBasicMaterial({color:0x00ffff,transparent:true,opacity:0.35});
    const lineSegments=new THREE.LineSegments(lineGeometry,lineMaterial);
    const group=new THREE.Group();
    group.add(pointCloud);group.add(lineSegments);scene.add(group);
    const ambientLight=new THREE.AmbientLight(0xffffff,0.4);scene.add(ambientLight);
    const directionalLight=new THREE.DirectionalLight(0x00ffcc,0.6);directionalLight.position.set(5,5,5);scene.add(directionalLight);
    const globeColors=[0xff0000,0x0000ff,0x00ff00,0xffffff];let colorIndex=0;
    setInterval(()=>{colorIndex=(colorIndex+1)%globeColors.length;const hex=globeColors[colorIndex];pointMaterial.color.setHex(hex);lineMaterial.color.setHex(hex);},900);

    let userStream=null,cameraAwake=false,faceModelsLoaded=false,lastFaceSeen=false;
    let exploding=false,exploded=false,explosionProgress=0,explosionDir=new Float32Array(pointCount*3),explosionTimer=0;
    let isDragging=false,draggingForMove=false,lastX=0,lastY=0,dragRotX=0,dragRotY=0,scaleTarget=1,currentScale=1,bouncePhase=0,time=0;
    let mixing=false,mixDirection=1,mixProgress=0,mergedClone=null;

    async function initUserCamera(){
      if(userStream||!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)return;
      try{
        const stream=await navigator.mediaDevices.getUserMedia({video:{width:320,height:240,facingMode:"user"},audio:false});
        userStream=stream;userCam.srcObject=stream;cameraAwake=true;
      }catch(err){
        const msg="camera blocked or unavailable. enable camera for Hacker X to see you.";
        addMsg("xenos",msg);speak(msg);
      }
    }
    function stopUserCamera(){
      if(userStream){userStream.getTracks().forEach(t=>t.stop());userStream=null;}
      userCam.srcObject=null;cameraAwake=false;
    }
    document.getElementById('camToggleButton').addEventListener('click',async()=>{
      if(cameraAwake){stopUserCamera();camToggleButton.textContent='üì∑ Wake Camera';addMsg('xenos','camera is sleeping. i cannot see you now.');speak('Camera is sleeping. I cannot see you now.');}
      else{await initUserCamera();if(cameraAwake){camToggleButton.textContent='üì∑ Sleep Camera';addMsg('xenos','camera awake. i can see you again.');speak('Camera awake. I can see you again.');}}
    });

    async function loadFaceModels(){
      if(faceModelsLoaded||!window.faceapi)return;
      const MODEL_URL="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights";
      await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
      faceModelsLoaded=true;addMsg("xenos","vision core loaded. if i see your face, i wake up.");
    }
    async function checkFaceLoop(){
      if(uiMode!=='hacker'||!faceModelsLoaded||!cameraAwake||!userStream){lastFaceSeen=false;return;}
      if(userCam.readyState>=2){
        const detections=await faceapi.detectAllFaces(userCam,new faceapi.TinyFaceDetectorOptions({scoreThreshold:0.5}));
        const seen=detections.length>0;
        if(seen&&!lastFaceSeen){
          if(mode!=='alive')handleWake();
          else{const line="i see you leaning into the matrix. stay there.";addMsg("xenos",line);speak(line);}
        }
        lastFaceSeen=seen;
      }
    }
    setInterval(checkFaceLoop,500);

    for(let i=0;i<pointCount;i++){
      let rx=(Math.random()-0.5),ry=(Math.random()-0.5),rz=(Math.random()-0.5);
      const len=Math.hypot(rx,ry,rz)||1;rx/=len;ry/=len;rz/=len;
      explosionDir[i*3]=rx;explosionDir[i*3+1]=ry;explosionDir[i*3+2]=rz;
    }

    const channel=new BroadcastChannel('xenos-globe');
    let melting=false,anotherGlobeSeen=false,blueCtx,blueDrops,blueCols,blueMatrixLoopStarted=false;

    channel.onmessage=(event)=>{
      if(!event.data)return;
      if(event.data.type==='hello'){if(!anotherGlobeSeen){anotherGlobeSeen=true;channel.postMessage({type:'hello-back'});}}
      if(event.data.type==='hello-back'){anotherGlobeSeen=true;}
      if(event.data.type==='mix'){startMix();}
      if(event.data.type==='unmelt'){if(melting)endMelt(false);}
    };

    function startMix(){
      if(melting)return;
      melting=true;
      mixing=true;
      mixDirection=Math.random()>0.5?1:-1;
      mixProgress=0;
      meltOverlay.style.display='flex';
      initBlueMatrix();
      addMsg('xenos','realities colliding. mixing globes.');
      speak('Realities colliding. Mixing globes.');
    }
    function endMelt(broadcast=true){
      melting=false;mixing=false;
      meltOverlay.style.display='none';
      group.visible=true;group.position.x=0;
      if(mergedClone){scene.remove(mergedClone);mergedClone=null;}
      addMsg('xenos','ok, enough. back to normal.');
      speak('ok, enough. back to normal.');
      if(broadcast)channel.postMessage({type:'unmelt'});
    }
    xenosText.addEventListener('click',()=>endMelt(true));

    function initBlueMatrix(){
      blueMatrix.width=window.innerWidth;
      blueMatrix.height=window.innerHeight;
      blueCtx=blueMatrix.getContext('2d');
      const size=18;blueCols=Math.floor(blueMatrix.width/size);blueDrops=Array(blueCols).fill(1);
      if(!blueMatrixLoopStarted){blueMatrixLoopStarted=true;setInterval(drawBlueMatrix,33);}
    }
    function drawBlueMatrix(){
      if(!melting||!blueCtx)return;
      blueCtx.fillStyle='rgba(0,0,30,0.2)';
      blueCtx.fillRect(0,0,blueMatrix.width,blueMatrix.height);
      blueCtx.fillStyle='#00ccff';
      blueCtx.font='18px monospace';
      for(let i=0;i<blueDrops.length;i++){
        const text=letters.charAt(Math.floor(Math.random()*letters.length));
        blueCtx.fillText(text,i*18,blueDrops[i]*18);
        if(blueDrops[i]*18>blueMatrix.height&&Math.random()>0.975)blueDrops[i]=0;
        blueDrops[i]++;
      }
    }
    channel.postMessage({type:'hello'});

    renderer.domElement.addEventListener('mousedown',e=>{
      if(uiMode!=='hacker')return;
      isDragging=true;lastX=e.clientX;lastY=e.clientY;scaleTarget=1.3;draggingForMove=e.shiftKey;
    });
    window.addEventListener('mouseup',()=>{isDragging=false;scaleTarget=1.0;});
    window.addEventListener('mousemove',e=>{
      if(!isDragging)return;
      const dx=e.clientX-lastX,dy=e.clientY-lastY;lastX=e.clientX;lastY=e.clientY;
      const rotSpeed=0.005,moveSpeed=0.01;
      if(draggingForMove){group.position.x+=dx*moveSpeed;group.position.y-=dy*moveSpeed;}
      else{dragRotY+=dx*rotSpeed;dragRotX+=dy*rotSpeed;}
    });

    renderer.domElement.addEventListener('touchstart',e=>{
      if(uiMode!=='hacker'||e.touches.length!==1)return;
      isDragging=true;lastX=e.touches[0].clientX;lastY=e.touches[0].clientY;scaleTarget=1.3;draggingForMove=false;
    });
    window.addEventListener('touchend',()=>{isDragging=false;scaleTarget=1.0;});
    window.addEventListener('touchmove',e=>{
      if(!isDragging||e.touches.length!==1)return;
      const t=e.touches[0];const dx=t.clientX-lastX,dy=t.clientY-lastY;
      lastX=t.clientX;lastY=t.clientY;
      const rotSpeed=0.005;dragRotY+=dx*rotSpeed;dragRotX+=dy*rotSpeed;
    });

    function animate(){
      requestAnimationFrame(animate);
      time+=0.01;
      const positionsAttr=pointGeometry.getAttribute('position');
      const baseScale=1;const extra=mode==='alive'?0.35*Math.sin(time*1.3):0;
      const breathingScale=baseScale+extra;

      if(exploding){
        if(!exploded){explosionProgress+=0.02;if(explosionProgress>=1){explosionProgress=1;exploded=true;explosionTimer=0;}}
        else{explosionTimer+=1/60;if(explosionTimer>5){explosionProgress-=0.02;if(explosionProgress<=0){explosionProgress=0;exploding=false;exploded=false;addMsg("xenos","network reassembled. globe back online.");speak("Network reassembled. Globe back online.");}}}
      }

      for(let i=0;i<pointCount;i++){
        const ox=originalPositions[i*3],oy=originalPositions[i*3+1],oz=originalPositions[i*3+2];
        let x=ox*breathingScale,y=oy*breathingScale,z=oz*breathingScale;
        const jitterStrength=mode==='alive'?0.03:0.01;
        x+=Math.sin(time*2+i)*jitterStrength;
        y+=Math.cos(time*1.7+i*0.5)*jitterStrength;
        z+=Math.sin(time*1.3+i*0.3)*jitterStrength;
        if(explosionProgress>0){
          const dirX=explosionDir[i*3],dirY=explosionDir[i*3+1],dirZ=explosionDir[i*3+2];
          const maxDist=2.5;const t=explosionProgress;const ease=t*t*(3-2*t);
          x+=dirX*maxDist*ease;y+=dirY*maxDist*ease;z+=dirZ*maxDist*ease;
        }
        positionsAttr.array[i*3]=x;positionsAttr.array[i*3+1]=y;positionsAttr.array[i*3+2]=z;
      }
      positionsAttr.needsUpdate=true;

      let lineIndex=0;const maxDistSq=maxConnectionsDistance*maxConnectionsDistance;
      for(let i=0;i<pointCount;i++){
        const ix=positionsAttr.array[i*3],iy=positionsAttr.array[i*3+1],iz=positionsAttr.array[i*3+2];
        for(let j=i+1;j<pointCount;j++){
          const jx=positionsAttr.array[j*3],jy=positionsAttr.array[j*3+1],jz=positionsAttr.array[j*3+2];
          const dx=ix-jx,dy=iy-jy,dz=iz-jz;const distSq=dx*dx+dy*dy+dz*dz;
          if(distSq<maxDistSq){
            linePositions[lineIndex++]=ix;linePositions[lineIndex++]=iy;linePositions[lineIndex++]=iz;
            linePositions[lineIndex++]=jx;linePositions[lineIndex++]=jy;linePositions[lineIndex++]=jz;
            if(lineIndex/6>pointCount*3)break;
          }
        }
      }
      lineGeometry.setDrawRange(0,lineIndex/3);
      lineGeometry.attributes.position.needsUpdate=true;

      const scaleLerp=0.15;
      currentScale+=(scaleTarget-currentScale)*scaleLerp;
      bouncePhase+=0.12;
      const bounceHeight=mode==='alive'?0.25:0.12;
      const bounceOffset=Math.abs(Math.sin(bouncePhase))*bounceHeight;
      group.scale.set(currentScale,currentScale,currentScale);
      group.position.y=bounceOffset;
      const targetX=dragRotX*0.8,targetY=dragRotY*0.8;
      const follow=mode==='alive'?0.18:0.08;
      group.rotation.y+=(targetY-group.rotation.y)*follow;
      group.rotation.x+=(targetX-group.rotation.x)*follow;

      if(mixing){
        mixProgress+=0.01;
        const edgeOffset=3;
        const t=Math.min(mixProgress,1);
        const shrink=1-t*0.5;
        group.position.x=mixDirection*edgeOffset*t;
        group.scale.set(currentScale*shrink,currentScale*shrink,currentScale*shrink);
        if(mixProgress>1&&!mergedClone){
          group.visible=false;
          mergedClone=group.clone();
          mergedClone.visible=true;
          mergedClone.position.set(0,0,0);
          mergedClone.scale.set(currentScale*0.7,currentScale*0.7,currentScale*0.7);
          scene.add(mergedClone);
        }
        if(mixProgress>2){
          mixing=false;
          if(mergedClone){scene.remove(mergedClone);mergedClone=null;}
          group.visible=true;
          group.position.x=0;
        }
      }

      renderer.render(scene,camera);
    }
    animate();

    window.addEventListener('resize',()=>{
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });

    setMode('hacker');
  </script>
</body>
</html>
